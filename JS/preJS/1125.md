class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        sid = {s: i for i, s in enumerate(req_skills)}  # 字符串映射到下标
        n = len(people)
        u = 1 << len(req_skills)
        # f[i+1][j] 表示从前 i 个集合中选择一些集合，并集等于 j，需要选择的最小集合
        f = [[0] * u for _ in range(n + 1)]
        f[0] = [(1 << n) - 1] * u  # 对应记忆化搜索中的 if i < 0: return (1 << n) - 1
        f[0][0] = 0
        for i, skills in enumerate(people):
            mask = 0
            for s in skills:  # 把 skills 压缩成一个二进制数 mask
                mask |= 1 << sid[s]
            for j in range(1, u):
                res = f[i][j]  # 不选 mask
                res2 = f[i][j & ~mask] | (1 << i)  # 选 mask
                f[i + 1][j] = res if res.bit_count() < res2.bit_count() else res2
        res = f[-1][-1]
        return [i for i in range(n) if (res >> i) & 1]  # 所有在 res 中的下标


//不适合用JS递归：数据范围、bit_count()

function bitcount(res){
    let cnt=0;
    while(res){
        cnt+= res&1 ;//最低位是否为1
        res >>=1; //下一位
    }
    return cnt;
}

var smallestSufficientTeam = function(mubiao, ziji) {
    const sid=mubiao.reduce((acc,el,idx)=>{
        acc.set(el,idx);
        return acc;
    },new Map());

    const N=ziji.length;
    const LM=mubiao.length;
    const U=1<<LM;
    const QuanJ=(1<<N)-1;

    const f=Array.from({length:N+1},()=>Array(U).fill(0));
    //fill并不能阻绝耦合关系    f[0].fill((1 << N) - 1);//一定不能再次赋值=     除非是深拷贝f[0]=[...Array(U).fill((1<<N) -1)];
    for(let j=0;j<U;j++){
        f[0][j]=QuanJ; //边界条件i<0
    }
    f[0][0]=0;

    for(let i=0;i<N;i++){ //遍历每个子集合物品
        let mask=0;
        for(const yuansu of ziji[i]){
            mask |= 1<<sid[yuansu]; //当前子集含有的元素
        }

        for(let j=1;j<U;j++){
            const res =f[i][j];
            const res2=f[i][j &~ mask] | (1<<i);
            f[i+1][j]=bitcount(res)<bitcount(res2) ? res:res2;
        }
    }

    const res=f[N][U-1]; //f.length-1][f[0].length-1]; 
           //N+1-1  U-1
    
    const ans=[];
    for(let i=0;i<N;i++){
        if ( (res>>i) & 1 ) ans.push(i);
    }
    return ans;
}


//不适合用JS递归：数据范围、bit_count()

function bitcount(res){
    let cnt=0;
    while(res){
        cnt+= res&1 ;//最低位是否为1
        res >>=1; //下一位
    }
    return cnt;
}

var smallestSufficientTeam = function(mubiao, ziji) {
    const sid=mubiao.reduce((acc,el,idx)=>{
        acc.set(el,idx);
        return acc;
    },new Map());

    const N=ziji.length;
    const LM=mubiao.length;
    const U=1<<LM;
    const QuanJ=(1<<N)-1;

    /*
    const f=Array.from({length:N+1},()=>Array(U).fill(0));
    //fill并不能阻绝耦合关系    f[0].fill((1 << N) - 1);//一定不能再次赋值=     除非是深拷贝f[0]=[...Array(U).fill((1<<N) -1)];
    for(let j=0;j<U;j++){
        f[0][j]=QuanJ; //边界条件i<0
    }
    */
    f=Array(U).fill(QuanJ);
    f[0]=0; //[0]=0;//j==0优先级在i<0之前

    for(let i=0;i<N;i++){ //遍历每个子集合物品
        let mask=0;
        for(const yuansu of ziji[i]){
            mask |= 1<<sid.get(yuansu); //当前子集含有的元素
        }               //是get！！！不能用[ ]

        for(let j=U-1;j>0;j--){
            const res =f[j];
            const res2=f[j &~ mask] | (1<<i);
            f[j]=bitcount(res)<bitcount(res2) ? res:res2;
        }
    
        /*
        for(let j=1;j<U;j++){
            const res =f[i][j];
            const res2=f[i][j &~ mask] | (1<<i);
            f[i+1][j]=bitcount(res)<bitcount(res2) ? res:res2;
        }
        */
    }

    const res=f[U-1]; //[N][U-1]; //f.length-1][f[0].length-1]; 
           //N+1-1  U-1
    
    const ans=[];
    for(let i=0;i<N;i++){
        if ( (res>>i) & 1 ) ans.push(i);
    }
    return ans;
}
